[TOC]

# 一、JVM

## 1、JVM定义

JVM（虚拟机）：指以软件的方式模拟具有完整硬件系统功能、运行在一个完全隔离环境中的计算机系统，是物理机的软件实现。

Java虚拟机是采用虚拟化技术，隔离出一块独立的子操作系统，使Java软件不受任何影响在虚拟机内进行执行。

JVM由三个主要的子系统构成：

- 类加载子系统：装载具有适合名称的类或接口
- 运行时数据区（内存结构）：包含方法区、Java堆、Java栈、本地方法栈、指令计数器及其他隐含寄存器
- 执行引擎：负责执行包含在已装载的类或接口中的指令

还有其他的子系统：

4. **本地方法接口（Native Interface）**：允许Java应用程序调用本地库中的本地方法，通常是用C或C++编写的。
5. **垃圾回收子系统**：负责管理内存中不再使用的对象，通过自动回收内存来避免内存泄漏。
6. **即时编译器（Just-In-Time Compiler，JIT）**：将字节码翻译成本地机器代码，以提高执行效率。
7. **安全子系统**：管理Java应用程序的安全性，包括类加载器安全、字节码验证和安全管理器。
8. **线程子系统**：负责管理Java应用程序中的线程，包括线程创建、同步和调度。
9. **垃圾收集器（Garbage Collector）**：实际执行垃圾回收的组件，有多种不同类型的垃圾收集器可用，包括串行、并行、并发和G1等。
10. **字节码校验器**：负责验证加载的字节码是否合法，以防止恶意代码的执行。

JVM实现了Java平台的无关性，JVM是虚拟的软件实现的硬件，所以**上面的所有系统都是虚拟的、抽象**的，他们组成了一个**抽象层**，使得java应用程序可以跨平台。

JVM在它的生存周期中有一个明确的任务，那就是运行Java程序，因此当Java程序启动的时候，就产生JVM的一个实例；当程序运行结束的时候，该实例也跟着消失了。

# 二、类加载子系统

## （1）什么是类的加载

将.class文件的二进制数据读入内存，放入运行时数据区的方法区内

在堆中创建class对象，用来封装类在法区的数据结构

类的加载的最终产品是位于堆中的class对象

## （2）类的生命周期

加载、连接、初始化、使用和卸载：

* 加载，查找并加载类的二进制数据，在Java堆中也创建一个java.lang.Class类的对象
* 连接，连接又包含三块内容：验证、准备、初始化。1）验证，文件格式、元数据、字节码、符号引用验证；2）准备，为类的静态变量分配内存，并将其初始化为默认值；3）解析，把类中的符号引用转换为直接引用
* 初始化，为类的静态变量赋予正确的初始值
* 使用，new出对象程序中使用
* 卸载，执行垃圾回收

## （3）类加载器

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190603164758648.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70)

启动类加载器：Bootstrap ClassLoader，是 Java 虚拟机的一部分，它负责加载核心 Java 类库，无法直接访问。

扩展类加载器：Extension ClassLoader，用于加载 Java 扩展库的类和资源，一般不太需要直接操作它。

应用程序类加载器：Application ClassLoader，用于加载应用程序的类和资源，可以直接使用。

```ClassLoader appClassLoader = getClass().getClassLoader(); 只会获取应用类加载器```

## （4）类加载机制

* 全盘负责：当一个类加载器负责加载某个Class时，该class依赖的和引用的其他Class也将由该类加载器负责载入，除非显示使用另外一个类加载器来载入
* 双亲委派机制：只有父类加载器无法加载才从自己的类路径中加载该类
* # 缓存机制：缓存机制会保证所有加载过的class都被缓存，只有缓存区不存在才会读取该类的二进制数据并转换成Class对象存入缓存区。所以修改了Class后需要重启JVM才会生效。

## （5）双亲委派机制流程

![在这里插入图片描述](https://img-blog.csdnimg.cn/2019060513594083.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70)

# 三、JVM内存管理

## （1）JVM内存结构（运行时数据区）



![在这里插入图片描述](https://img-blog.csdnimg.cn/20190605145421204.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5OTY2MjAz,size_16,color_FFFFFF,t_70)

方法区和堆是**所有线程共享**的内存区域；

java栈、本地方法栈和程序计数器是**运行时线程私有**的内存区域。

一个.class文件装载到内存后会划分为以下五部分：
方法区（method），堆内存（heap），栈内存（stack），本地方法栈（java中的jni调用），程序计数器

### （1.1）Java堆（Heap）

作用：存放对象实例，无法申请到内存时抛出OOM

组成：

java8（jdk1.8）之前：新生代、老年代和永久代

java8（jdk1.8）之后：新生代、老年代（永久代变为元空间作为真实内存独立出来了，不再是堆内存中的一部分）

**（1）新生代**

组成：Eden区和Survivor区(Survivor0,Survivor1)  8:1:1。

MinorGC过程：

对象在Eden区生成，Eden空间不足发起GC。先将Eden区存活对象复制到S0，清空Eden。当S0满之后将Eden和S0存活对象复制到S1，并将S0和S1交换，保持S1为空。当S1在复制时满了，则将剩余的存活对象放入老年代。当对象在S区存活一轮则年龄加1，默认情况到达15岁会移动到老年代。

**（2）老年代**

放入对象：

1.在S区中年龄到达15岁

2.大对象直接分配到老年代

3.S1区内存不足时剩余的存活对象放入老年代

4.如果Survivor区中相同年龄的所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

老年代也满了会触发一次Full GC。

**（3）永久代（元空间）**

存储类的元数据，包括了关于类的结构、方法、字段、常量池、注解等描述性信息，用于描述类的特性和结构。

### （1.2）方法区（Method Area）

**类的元数据+方法字节码+接口代码+运行时常量池+字符串常量池**，方法区是类逻辑上的一个抽象模板，而永久代\元空间是**方法区的实现**，是真实存在的内存。

类的元数据：接口的方法签名和方法表、类的类名、方法、字段（静态变量）、注解、常量池，用于描述类的特性和结构。

**常量池**：常量池包含类的常量池、字符串常量池和运行时常量池。

类的常量池是类文件（.class 文件）的一部分，不存在方法区中，它包括在编译时确定的常量，如类、接口、字段和方法的符号引用。在运行时被加入到运行时常量池中。

字符串常量池：用于在编译时就将字符串的字面量存储进来。

运行时常量池在运行时会将类的常量池、字符串常量池和运行时生成的常量加载进来。

**注意：**字符串常量通常存储在堆内存中，运行时常量池中存储的是对字符串常量池中的字面量的引用。

### （1.3）程序计数器（Program Counter Register）

当前线程所执行的字节码的行号指示器

### （1.4）JVM栈（JVM Stacks）

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190605141437563.png)

组成：局部变量区和操作数栈，局部变量区用于存放方法中的局部变量和参数，操作数栈中用于存放方法执行过程中产生的中间结果。

每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。不存在垃圾回收问题，只要线程已结束栈就出栈，生命周期与线程一致。

作用：

存储基础数据类型、形参、引用数据类型的引用（用new创建的）、方法的引用参数。

### （1.5）本地方法栈（[Native](https://so.csdn.net/so/search?q=Native&spm=1001.2101.3001.7020) Method Stacks）

java中jni调用。用于支持native方法执行，存储了每个native方法调用的状态。

# 七、Java代码编译和执行的整个过程包含了三个重要机制

- Java源码编译机制（生成class文件）
- 类加载机制（加载class文件进内存）
- 类执行机制（虚拟机执行）

# 八、Java虚拟机和Dalvik虚拟机区别

java虚拟机运行的是Java字节码，Dalvik虚拟机运行的是Dalvik字节码；传统的Java程序经过编译，生成Java字节码保存在class文件中，java虚拟机通过解码class文件中的内容来运行程序。而Dalvik虚拟机运行的是Dalvik字节码，所有的Dalvik字节码由Java字节码转换而来，并被打包到一个DEX(Dalvik Executable)可执行文件中Dalvik虚拟机通过解释Dex文件来执行这些字节码。
Dalvik可执行文件体积更小。SDK中有一个叫dx的工具负责将java字节码转换为Dalvik字节码。
java虚拟机与Dalvik虚拟机架构不同。java虚拟机基于栈架构。程序在运行时虚拟机需要频繁的从栈上读取或写入数据。这过程需要更多的指令分派与内存访问次数，会耗费不少CPU时间，对于像手机设备资源有限的设备来说，这是相当大的一笔开销。Dalvik虚拟机基于寄存器架构，数据的访问通过寄存器间直接传递，这样的访问方式比基于栈方式快的多


# String

多次调用 `String str = "Hello";` 不会创建新的对象，Hello已经存在于字符串常量池中，每次调用都会返回对相同字符串对象的引用。

多次调用 `String str = new String("Hello");` 会创建新的字符串对象，但不会检查字符串常量池，也不会将新的字面量加入常量池中。
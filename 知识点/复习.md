# 复习

## 抽象类与接口的区别

设计目的：

抽象类：代码复用，接口：约束类的行为，把模块进行固化契约，降低耦合。

抽象类是is-a的关系，而接口是has-a的关系。

抽象类是为了将共有的代码抽象出来，而接口可以方便拓展。



## 静态内部类、抽象类、接口能被实例化吗？为什么？

实例化：在内存中分配一块空间。

静态内部类能。抽象类不能。接口不能。

静态内部类是属于类的，所以在不实例化的时候可以直接调用，但实例化了也能够调用。

抽象类是不能被实例化的，目的是为了不让使用该类。但能通过子类间接实例化，也能通过匿名类间接实例化。

接口也是不能被实例化的。因为接口内没有实现方法（java 1.8之后可以定义default方法），实例化是没有意义的，所以java直接禁止了此行为。



## java的参数传递是值传递还是地址传递

值传递！！

对于基本数据类型（如 int、float、boolean 等），传递的是其实际的数值，而对于对象，传递的是对象的引用（内存地址）。

而地址传递指的是直接传递对象的内存地址，



## finally中的代码一定会执行吗？try里有return，finally还执行么

在try中存在return的情况下，会把try中return的值存到栈帧的局部变量表中，然后去执行finally语句块，最后再从局部变量表中取回return的值返回。另外，当try和finally里都有return时，会忽略try的return，而使用finally的return。

#### 特殊情况

如果我们将执行try-catch-finally 代码块的线程设置为守护线程，或者在fianlly之前调用`System.exit`结束当前虚拟机，那么finally则不会得到执行	



## Java异常机制中，异常Exception与错误Error区别

答：Error是程序无法处理的错误，Exception是程序可以处理的异常。Exception又分为运行时异常和其他（非运行时异常），运行时异常是程序在运行中才会暴露出来的异常，而非运行时异常是程序在编译期间就会检查的异常，所以必须进行处理，否则不能通过编译。



在Java中存在一个`Throwable`可抛出类，`Throwable`有两个重要的子类，一个是Error，另一个则是Exception。

`Error`是程序不能处理的错误，表示程序中较严重问题。例如，Java虚拟机运行错误（Virtual MachineError），当 JVM 不再有继续执行操作所需的内存资源时，将出现 OutOfMemoryError等等。这些错误发生时，JVM一般会选择线程终止。这些错误是不可查的，它们在程序的控制和处理能力之外，而且绝大多数是程序运行时不允许出现的状况。

`Exception`是程序可以处理的异常。而Exception又分为运行时异常（RuntimeException）与非运行时异常。

- 运行异常

  运行时异常，**又称不受检查异常** 。所谓的不受检查，指的是Java编译检查时不会告诉我们有这个异常，需要在运行时候才会暴露出来，比如下标越界，空指针异常等。 

- 非运行时异常

  RuntimeException之外的异常我们统称为**非运行时异常**，比如IOException、SQLException，是必须进行处理的异常（**检查异常**） ，如果不处理（throw到上层或者try-catch），程序就不能编译通过 。

  

## 序列Parcelable,Serializable的区别？

1、Serializable是Java提供的序列化机制，而 Parcelable则是Android提供的适合**内存**中进行传输的序列化方式，效率比较高但是实现起来复杂一些。

2、Serializable不需要实现任何方法，只是一种标记。

Parcelable需要实现writeToParcel方法并且创建一个非空的静态变量 CREATOR。

3、Parcelable的原理是通过Parcel来传递数据，它先将一个完整的对象进行分解，而分解后的每一部分都是基本数据类型或者其他实现了Parcelable/Serializable的类型，从而实现传递对象的功能。

4、如果只需要在内存中进行数据传输是，序列化应该选择Parcelable，而如果需要存储到设备或者网络传输上应该选择Serializable。这是因为Android不同版本Parcelable数据规则可能不同，所以不推荐使用Parcelable进行数据持久化。

## 为什么Intent传递对象需要序列化？

Intent本质上是使用Binder完成的，Intent启动组件后需要借助AMS的system_server完成，因此startActivity会离开当前进程，即跨进程通信。而由于进程隔离的存在，无法直接获取应用进程内存的对象，所以只能通过复制的方式将它传递给system_server进而传递给应用中的OtherAcitivity。

而Parcelable,Serializable分别将对象写入Parcel和文件中，两种方式都可以实现跨进程通信。



在Android中使用Intent传输数据除了基本数据类型之外，对于其他类型对象需要此类型实现了Serializable或者Parcelable序列化接口才能进行传输。

以startActivity为例：

```
Intent intent = new Intent(context,OtherActivity.class);
//字符串实现了Serializable序列化
intent.putExtra("a","享学");
//Message实现了Parcelable序列化
intent.putExtra("b",new android.os.Message());
//错误：上下文context并未实现序列化
intent.putExtra("c",context);
startActivity(intent);
```

Intent传输数据本质上是使用Binder来完成的。Intent启动组件需要借助AMS完成，因此`startActivity`会离开当前应用进程，进入AMS所在的system_server进程进行跨进程通信。这就意味着传输的对象需要在不同进程之间进行传输。

为了保护不同进程互不干扰，进程隔离让system_server进程无法直接获取应用进程内存中的对象。因此必须通过类似于复制的手段，将应用进程的对象传递给system_server进程，再由system_server进程传递给应用中的`OtherActivity`。

根据**《序列Parcelable,Serializable的区别？》**可知，Serializable会利用IO将对象写入到文件中；而Parcelable则会将对象写入到Parcel中，两种方式都可以解决跨进程的数据传递。因此Intent传递的对象需要实现Serializable或者Parcelable序列化。

## 泛型是什么，泛型擦除呢？

泛型就是一种就是一种不确定的数据类型。

#### 泛型的优点

我们为什么需要使用泛型：

1. 适用于多种数据类型执行相同的代码，例如两个数据相加：
2. 编译检查，类型不对编译时会报错

#### 泛型的缺点

1. 静态域或者方法里不能引用泛型变量，因为泛型是在new对象的时候才知道，而类的构造方法是在静态变量之后执行。
2. 无法在运行时捕获泛型类对象

#### 泛型擦除

Jdk中实现的泛型实际上是伪泛型，例如泛型类 Fruit<T> ，编译时 T 会被擦除，成为 Object。
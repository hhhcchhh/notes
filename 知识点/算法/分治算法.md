# 分治算法

## 一、典型二分法

在算法设计中，每次一个问题分解成的子问题个数一般是固定的，每个子问题的规模也是平均分配的。当每次都将问题分解为原问题规模的一半时，称为二分法。

### **问题：金块问题** 

老板有一袋金块（共n块），最优秀的雇员得到其中最重的一块，最差的雇员得到其中最轻的一块，假设有一台比较重量的仪器，我们希望用最少的比较次数找出最重的金块。







任务调度

```java
public class teskDispatch {
    /*
     * 给你k个任务和n台机器，其中机器i处理一个任务所需的时间为t_{i};
     * 求处理所有任务所需的最短时间。
     * 比如k=8，n=3，t[1..3] ={2,3,1}时，最短时间为9
     * */
    /*
     * 递归思路
     * 将一个任务分配给一台机器，然后递归分配剩余任务。
     * 尝试探索所有可能的任务分配方式，然后找到最短时间的分配方式。
     * */
    /*
     * 非递归分治思路
     * 当时间固定时此时的任务是可以求出来的
     * 所以解题关键在于找到最大的时间，然后将时间分割直到找到需要的时间为止
     *
     * */
    public static int findShortestTime(int meshines, int task, int[] times) {
        //
        int minTime = 1;
        int maxTime = getMaxTime(times, task);
        times = new int[]{1, 2, 3};

        int totalTime = (minTime + maxTime) / 2;
        int completedTask = completedTask(totalTime, times);
        while (maxTime > minTime) {
            if (completedTask > task) {
                maxTime = totalTime - 1;
                totalTime = (minTime + maxTime) / 2;
            } else if (completedTask < task){
                minTime = totalTime + 1;
                totalTime = (minTime + maxTime) / 2;
            }
            completedTask = completedTask(totalTime, times);
        }
        return maxTime;
    }

    private static int getMaxTime(int[] times, int task) {
        int minTime = Integer.MAX_VALUE;
        for (int time : times) {
            if (time < minTime) minTime = time;
        }
        return minTime * task;
    }

    //输入时间、机器耗费的时间数列，返回任务量
    private static int completedTask(int totalTime, int[] times) {
        int completedTask = 0;
        for (int time : times) {
            completedTask += totalTime / time;
        }
        return completedTask;
    }
}
```


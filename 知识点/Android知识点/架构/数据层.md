# 数据层

原文：https://developer.android.google.cn/topic/architecture/data-layer?hl=zh-cn#architecture

## 数据层架构

数据层由多个存储库组成，其中每个存储库都可以包含零到多个数据源。您应该为应用中处理的每种不同类型的数据分别创建一个存储库类。例如，您可以为与电影相关的数据创建一个 `MoviesRepository` 类，或者为与付款相关的数据创建一个 `PaymentsRepository` 类。

![在典型架构中，数据层的存储库会向应用的其余部分提供数据，并且依赖于数据源。](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-data-overview.png?hl=zh-cn)

存储库类负责以下任务：

- 向应用的其余部分公开数据。
- 集中处理数据变化。
- 解决多个数据源之间的冲突。
- 对应用其余部分的数据源进行抽象化处理。
- 包含业务逻辑。

1. **向应用的其余部分公开数据**： 存储库类为应用程序的其他部分提供了访问数据的**统一接口**。这意味着它可以**封装底层数据源**（例如数据库、网络服务等），并为其他组件（如 ViewModel、Presenter 或 Controller）提供对这些数据的访问。
2. **集中处理数据变化**： 存储库类通常负责监视数据变化并将这些变化通知给应用程序其他部分。它可以管理数据的更新、插入、删除等操作，并确保应用程序的其他部分能够及时获取到数据的变化。（liveData、RxJava、Callbacks 或接口回调、LocalBroadcastManager 或 EventBus）
3. **解决多个数据源之间的冲突**： 如果应用程序使用多个数据源（例如本地数据库和远程服务器），存储库类可以处理这些数据源之间的冲突。它可能负责同步数据、处理冲突并提供一致的数据访问接口。
4. **对应用其余部分的数据源进行抽象化处理**： 假设一个天气应用，存储库类可能负责提供天气信息。它可能同时从不同的数据源（例如天气 API、本地缓存等）获取天气数据，但对于其他部分来说，它只暴露一个统一的获取天气数据的方法，隐藏了底层数据源的实现细节。
5. **包含业务逻辑**： 在一个任务管理应用中，存储库类可能会负责处理任务的状态变化。例如，当用户完成一个任务时，存储库类可能会执行一些业务逻辑，如更新任务状态、记录完成时间等。

> Tips：
>
> 每个数据源类应仅负责处理一个数据源。
>
> 层次结构中的其他层绝不能直接访问数据源；数据层的入口点始终是存储库类。
>
> **该层公开的数据应该是不可变的**，这样就可以避免数据被其他类篡改，从而避免数值不一致的风险，也可以由多个线程安全地处理。
>
> 按照[依赖项注入](https://developer.android.google.cn/training/dependency-injection?hl=zh-cn)方面的最佳实践，存储库应在其构造函数中将数据源作为依赖项：（可以是文件、网络来源或本地数据库（数据库类的实例））

```java
class ExampleRepository(
    private val exampleRemoteDataSource: ExampleRemoteDataSource, // network
    private val exampleLocalDataSource: ExampleLocalDataSource // database
) { /* ... */ }
```

## 公开 API

数据层中的类通常会公开函数，以执行一次性的创建、读取、更新和删除 (CRUD) 调用，或接收关于数据随时间变化的通知。对于每种情况，数据层都应公开以下内容：

- **一次性操作**：在 Kotlin 中，数据层应公开挂起函数；对于 Java 编程语言，数据层应公开用于提供回调来通知操作结果的函数，或公开 RxJava `Single`、`Maybe` 或 `Completable` 类型。
- **接收关于数据随时间变化的通知**：在 Kotlin 中，数据层应公开[数据流](https://developer.android.google.cn/kotlin/flow?hl=zh-cn)；对于 Java 编程语言，数据层应公开用于发出新数据的回调，或公开 RxJava `Observable` 或 `Flowable` 类型。

## 命名惯例

存储库类以其负责的数据命名。具体命名惯例如下：

数据类型 + Repository。

例如：`NewsRepository`、`MoviesRepository` 或 `PaymentsRepository`。

数据源类以其负责的数据以及使用的来源命名。具体命名惯例如下：

数据类型 + 来源类型 + DataSource。

对于数据的类型，可以使用 Remote 或 Local，以使其更加通用，因为实现是可以变化的。例如：`NewsRemoteDataSource` 或 `NewsLocalDataSource`。在来源非常重要的情况下，为了更加具体，可以使用来源的类型。例如：`NewsNetworkDataSource` 或 `NewsDiskDataSource`。

请勿根据实现细节来为数据源命名（例如 `UserSharedPreferencesDataSource`），因为使用相应数据源的存储库应该不知道数据是如何保存的。

> 如果您遵循此规则，便可以更改数据源的实现（例如，从 [SharedPreferences](https://developer.android.google.cn/training/data-storage/shared-preferences?hl=zh-cn) 迁移到 [DataStore](https://developer.android.google.cn/topic/libraries/architecture/datastore?hl=zh-cn)），而不会影响调用相应数据源的层。

## 多层存储库

在某些涉及更复杂业务要求的情况下，存储库可能需要依赖于其他存储库。

例如，负责处理用户身份验证数据的存储库 `UserRepository` 可以依赖于其他存储库（例如 `LoginRepository` 和 `RegistrationRepository`），以满足其要求。

![在示例中，UserRepository 依赖于另外两个存储库类，即依赖于其他登录数据源的 LoginRepository 和依赖于其他注册数据源的 RegistrationRepository。](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-data-multiple-repos.png?hl=zh-cn)

> **注意**：传统上，一些开发者将依赖于其他存储库类的存储库类称为 manager，例如称为 `UserManager` 而非 `UserRepository`。如果您愿意，可以使用此命名惯例。

## 可信来源

每个存储库都只定义单个可信来源，这一点非常重要。可信来源始终包含一致、正确且最新的数据。实际上，从存储库公开的数据应始终是直接来自可信来源的数据。

可信来源可以是数据源（例如数据库），甚至可以是存储库可能包含的内存中缓存。存储库可合并不同的数据源，并解决数据源之间的所有潜在冲突，以便定期更新或因应用户输入事件更新单个可信来源。

应用中的不同存储库可以具有不同的可信来源。例如，`LoginRepository` 类可以将其缓存用作可信来源，`PaymentsRepository` 类则可以使用网络数据源。

为了提供离线优先支持，**建议使用本地数据源（例如数据库）作为可信来源**。

## 线程处理

调用数据源和存储库应该具有主线程安全性(耗时逻辑放到其他线程去)

大部分数据源都已提供具有主线程安全性的 API，例如 [Room](https://developer.android.google.cn/training/data-storage/room?hl=zh-cn) 或 [Retrofit](https://square.github.io/retrofit/) 提供的挂起方法调用。

如需详细了解线程处理，请参阅[后台处理指南](https://developer.android.google.cn/guide/background?hl=zh-cn)。对于 Kotlin 用户，建议使用[协程](https://developer.android.google.cn/kotlin/coroutines?hl=zh-cn)。如需了解针对 Java 编程语言的推荐选项，请参阅[在后台线程中运行 Android 任务](https://developer.android.google.cn/guide/background/threading?hl=zh-cn)。

## 生命周期

最好将数据层实例的生命周期限定为负责相应流程的生命周期的类。

例如，您可以将包含内存中数据的 `RegistrationRepository` 的作用域限定为 `RegistrationActivity`，或限定为注册流程的[导航图](https://developer.android.google.cn/guide/navigation/navigation-getting-started?hl=zh-cn#create-nav-graph)。

每个实例的生命周期都是决定如何在应用内提供依赖项的关键因素。建议您遵循[依赖项注入](https://developer.android.google.cn/training/dependency-injection?hl=zh-cn)方面的最佳实践来管理依赖项，并可以将依赖项的作用域限定为依赖项容器。如需详细了解 Android 中的作用域限定，请参阅 [Android 和 Hilt 中的作用域限定](https://medium.com/androiddevelopers/scoping-in-android-and-hilt-c2e5222317c0)博文。

## **分离模型类**

当你在数据源中拿到的数据比你在应用中使用的多的时候，你应该考虑创建新的数据模型，并仅公开需要的数据

好处：

- 将数据减少到只包含需要的内容，从而节省应用内存。
- 根据应用所使用的数据类型来调整外部数据类型 - 例如，应用可以使用不同的数据类型来表示日期。
- 更好地分离关注点 - 例如，如果预先定义了模型类，大型团队的成员便可以在功能的网络层和界面层单独开展工作。

## 数据操作类型

数据层可以处理的操作类型会因操作的重要程度而异：面向界面的操作、面向应用的操作和面向业务的操作。

### 面向界面的操作

面向界面的操作仅在用户位于特定屏幕上时才相关，当用户离开相应屏幕时便会被取消。例如，显示从数据库获取的部分数据。

面向界面的操作通常由界面层触发，并且遵循调用方的生命周期，例如 ViewModel 的生命周期。如需查看面向界面的操作的示例，请参阅[发出网络请求](https://developer.android.google.cn/topic/architecture/data-layer?hl=zh-cn#network-request)部分。

### 面向应用的操作

只要应用处于打开状态，面向应用的操作就一直相关。如果应用关闭或进程终止，这些操作将会被取消。例如，缓存网络请求结果，以便在以后需要时使用。如需了解详情，请参阅[实现内存中数据缓存](https://developer.android.google.cn/topic/architecture/data-layer?hl=zh-cn#in-memory-cache)部分。

这些操作通常遵循 `Application` 类或数据层的生命周期。如需查看示例，请参阅[让操作拥有比屏幕更长的生命周期](https://developer.android.google.cn/topic/architecture/data-layer?hl=zh-cn#make_an_operation_live_longer_than_the_screen)部分。

### 面向业务的操作

面向业务的操作无法取消。它们应该会在进程终止后继续执行。例如，完成上传用户想要发布到其个人资料的照片。

对于面向业务的操作，建议使用 WorkManager。如需了解详情，请参阅[使用 WorkManager 调度任务](https://developer.android.google.cn/topic/architecture/data-layer?hl=zh-cn#workmanager)部分。

## 公开错误

与存储库和数据源的互动可能会成功，也可能会在出现故障时抛出异常。对于协程和数据流，您应使用 Kotlin 的[内置错误处理机制](https://kotlinlang.org/docs/exception-handling.html)。对于可以由挂起函数触发的错误，可以在适当时使用 `try/catch` 块；在数据流中，可以使用 [`catch`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/catch.html) 运算符。如果使用这种方式，界面层应负责处理在调用数据层时出现的异常。

数据层可以理解和处理不同类型的错误，并可以使用自定义异常（例如 `UserNotAuthenticatedException`）公开这些错误。

> **注意**：若要为与数据层的互动结果建模，另一种方法是使用 `Result` 类。此模式会为在处理结果时可能出现的错误和其他信号进行建模。在此模式中，数据层会返回 `Result<T>` 类型，而非 `T`，以便让界面知道在特定情况下可能发生的已知错误。对于没有适当异常处理机制的反应式编程 API（例如 [LiveData](https://developer.android.google.cn/topic/architecture/topic/libraries/architecture/livedata?hl=zh-cn)）来说，必须要使用这种方法。

如需详细了解协程中的错误，请参阅[协程中的异常](https://medium.com/androiddevelopers/exceptions-in-coroutines-ce8da1ec060c)博文。

## 常见任务

见原文举例



## 存储库类和ViewModel的区别

- **ViewModel 持有数据**：

  - 将与用户界面直接相关的数据放在 ViewModel 中，以便在界面的生命周期内持有和管理数据。
  - ViewModel 可以向存储库请求数据，处理存储库返回的数据，并将其转换为界面可以直接使用的格式。

- **存储库提供数据**：

  - 存储库负责从数据源获取数据，并将数据提供给 ViewModel。
  - 存储库可能使用 LiveData 或其他观察者模式来向 ViewModel 提供数据，使得 ViewModel 能够观察数据的变化。

  ViewModel是用来持有和处理界面相关的数据，而存储库是用来持有数据源相关的数据。

## 存储库类和数据库类的区别

负责创建数据库的实例，并提供访问数据访问对象（DAO）的方法。通过 DAO，我们可以执行诸如插入、更新、查询等数据库操作。整个数据库的配置和初始化都在 `TaskDatabase` 类中进行定义和管理。

`TaskDatabase` 类是用来创建和管理 Room 数据库实例的，而不是存储和处理特定数据的地方。实际的数据操作应该放在存储库类中。

`TaskRepository` 类就是存储库类。它使用 `TaskDao` 来操作 Room 数据库，并提供对任务数据的访问和操作。存储库类负责实现业务逻辑和具体的数据操作，如插入、更新、查询等。

**数据库类：获取 DAO 对象的一个入口点、数据库初始化、数据库升级、数据迁移。负责配置和管理 数据库的实例**

**存储库类：获取 DAO 对象、插入、删除、更新（可能封装在异步任务中），控制数据的获取和操作**
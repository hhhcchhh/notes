# 界面层

## 介绍

数据层传递过来的数据格式可能和要显示的格式不同，你应该将这些数据转化为界面可呈现的格式。

![在典型架构中，界面层的界面元素依赖于状态容器，而状态容器又依赖于来自数据层或可选网域层的类。](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-overview.png?hl=zh-cn)

## 界面层架构

“界面”指用于显示数据的 activity 和 fragment 等界面元素

由于[数据层](https://developer.android.google.cn/jetpack/guide/data-layer?hl=zh-cn)的作用是存储和管理应用数据，以及提供对应用数据的访问权限，因此界面层必须执行以下步骤：

1、使用数据并转化为可以轻松呈现的数据。

2、将可呈现数据转化为界面元素。

3、使用界面元素的输入事件来控制数据。

## 定义界面状态

界面（界面元素）是用户的可视页面，而界面状态（ViewModel）是界面上显示的信息。对界面状态的修改都会立即反映在界面上。

![界面是将屏幕上的界面元素与界面状态绑定在一起的结果。](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-elements-state.png?hl=zh-cn)

### 不可变性

界面状态的来源是数据类。在定义数据类时应该将数据定义为不可变的（val），这样界面可发挥单一作用：读取状态并相应的更新对应元素。

> 切勿直接在界面中修改界面状态，除非界面本身是数据的唯一来源。违反这个原则会导致同一条信息有多个可信来源（与数据层的数据更新冲突。）进而导致数据不一致或轻微bug。

### 命名惯例

界面状态类是根据其描述的屏幕或部分屏幕的功能命名的。命名惯例如下：

功能 + UiState。

例如，用于显示新闻的屏幕的状态可以称为 `NewsUiState`，新闻报道列表中的新闻报道的状态可以为 `NewsItemUiState`。

## 使用单向数据流管理状态

上一部分中指出，界面状态是呈现界面所需的详细信息的不可变快照。不过，应用中数据的动态特性意味着状态可能会随时间而变化。这可能是因为用户互动，也可能是因为其他事件修改了用于填充应用的底层数据。

这些互动及其逻辑不应该位于界面本身中，界面的唯一职责应该是使用和显示界面状态。除非界面状态非常简单。

单向数据流 (UDF)是一种架构模式，有助于强制实施这种健康的职责分离。

### 状态容器

符合以下条件的类称为状态容器：负责提供界面状态，并且包含执行相应任务所必需的逻辑。状态容器有多种大小，具体取决于所管理的界面元素的作用域（从[底部应用栏](https://material.io/components/app-bars-bottom)等单个微件，到整个屏幕或导航目的地，不一而足）。

在后一种情况下，典型的实现是 [ViewModel](https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn) 的实例

> **要点**：[`ViewModel`](https://developer.android.google.cn/topic/libraries/architecture/viewmodel?hl=zh-cn) 类型是推荐的实现，用于管理**屏幕级界面状态**，具有数据层访问权限。此外，它会在配置发生变化后自动继续存在。`ViewModel` 类用于定义要为应用中的**事件应用的逻辑**，并**提供更新后的状态**作为结果。

您可以通过多种方式为界面与其状态提供方之间的互相依赖关系建模。不过，由于界面与其 `ViewModel` 类之间的互动在很大程度上可以理解为事件输入及其随后的状态输出，因此这种关系可以按下图所示来表示：

![应用数据从数据层流向 ViewModel。界面状态从 ViewModel 流向界面元素，事件从界面元素流回 ViewModel。](https://developer.android.google.cn/static/topic/libraries/architecture/images/mad-arch-ui-udf.png?hl=zh-cn)

状态向下流动、事件向上流动的这种模式称为单向数据流 (UDF)。这种模式对应用架构的影响如下：

- ViewModel 会存储并公开界面要使用的状态。界面状态是经过 ViewModel 转换的应用数据。
- 界面会向 ViewModel 发送用户事件通知。
- ViewModel 会处理用户操作并更新状态。
- 更新后的状态将反馈给界面以进行呈现。
- 系统会对导致状态更改的所有事件重复上述操作。

对于导航目的地或屏幕，ViewModel 会使用存储库或用例类来获取数据并将其转换为界面状态，同时纳入可能会导致状态更改的事件的影响。

用户请求为报道添加书签就是一个可能会导致状态更改的事件示例。作为状态提供方，ViewModel 的职责是定义所有必需的逻辑，以便填充界面状态中的所有字段，并处理界面完全呈现所需的事件。

以下几个部分更详细地介绍了导致状态变化的事件，以及如何使用 UDF 处理这些事件。

### 逻辑类型

- **业务逻辑**决定着如何处理状态变化。如前面所述，一个例子是在案例研究应用中为报道添加书签。业务逻辑通常位于网域层或数据层中，但绝不能位于界面层中。
- **界面行为逻辑**或**界面逻辑**决定着如何在屏幕上显示状态变化。示例包括：使用 Android [`Resources`](https://developer.android.google.cn/reference/android/content/res/Resources?hl=zh-cn) 获取要在屏幕上显示的正确文本、在用户点击某个按钮时转到特定屏幕，或使用[消息框](https://developer.android.google.cn/guide/topics/ui/notifiers/toasts?hl=zh-cn)或[信息提示控件](https://developer.android.google.cn/training/snackbar?hl=zh-cn)在屏幕上向用户显示消息。

界面逻辑（尤其是在涉及 [`Context`](https://developer.android.google.cn/reference/android/content/Context?hl=zh-cn) 等界面类型时）应位于界面中，而非 ViewModel 中。如果界面变得越来越复杂，并且您希望将界面逻辑委托给另一个类，以便有利于进行测试和关注点分离，**您可以创建一个简单的类作为状态容器**(将对数据的相关操作抽出来放一起)。在界面中创建的简单类可以采用 Android SDK 依赖项，因为它们遵循界面的生命周期；ViewModel 对象具有更长的生命周期。

> 当你的代码依赖于 Android SDK 时，它可能涉及使用诸如 `Context`、`Activity`、`Fragment`、`Intent` 等 Android 框架提供的类或者相关功能。这些类和功能可以访问设备的硬件、提供界面交互、管理生命周期等。

### 为何使用 UDF？

UDF 有助于实现以下几点：

- **数据一致性**。界面只有一个可信来源。
- **可测试性**。状态来源是独立的，因此可独立于界面进行测试。
- **可维护性**。状态的更改遵循明确定义的模式，即状态更改是用户事件及其数据拉取来源共同作用的结果。

## 公开界面状态

定义界面状态并确定如何管理相应状态的提供后，下一步是将提供的状态发送给界面。由于您使用 UDF 管理状态的提供，因此您可以将提供的状态视为数据流，因此，您应在 `LiveData` 或 `StateFlow` 等可观察数据容器中公开界面状态。这样做是为了使界面可以对状态的任何变化做出反应，而无需直接从 ViewModel 手动拉取数据。这些类型还有一个好处是，始终缓存界面状态的最新版本

创建 `UiState` 流的一种常用方法是，将后备可变数据流作为来自 ViewModel 的不可变数据流进行公开，例如将 `MutableStateFlow<UiState>` 作为 `StateFlow<UiState>` 进行公开。

```java
class NewsViewModel(...) : ViewModel() {

    private val _uiState = MutableStateFlow(NewsUiState())
    val uiState: StateFlow<NewsUiState> = _uiState.asStateFlow()
    ...

}
```

这样一来，ViewModel 便可以公开在内部更改状态的方法，以便发布供界面使用的更新。而不是直接暴露可变的状态让外部更新，这样提供了一种清晰的界面与数据层分离的方法，ViewModel 在内部就可以管理状态的变化。

### 其他注意事项

**将彼此相关的状态放在相同的界面状态对象内。**避免状态不一致的情况。

**界面状态：单个数据流还是多个数据流？**单个数据流中进行公开的最大优势是便捷性和数据一致性：状态的使用方随时都能立即获取最新信息。不过，在有些情况下，可能适合使用来自 ViewModel 的单独的状态流：

- **不相关的数据类型**：呈现界面所需的某些状态可能是完全相互独立的。在此类情况下，将这些不同的状态捆绑在一起的代价可能会超过其优势，当其中某个状态的更新频率高于其他状态的更新频率时可能会导致全部频繁的更新。
- 由于视图没有 diffing 机制来了解连续发出的数据流是否相同，因此每次发出都会导致视图更新。可能必须要对 `LiveData` 使用 `Flow` API 或 [`distinctUntilChanged()`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/distinct-until-changed.html) 等方法来缓解这个问题。

## 使用界面状态

如需在界面中使用 `UiState` 对象流，您可以对所使用的可观察数据类型使用终端运算符。例如，对于 `LiveData`，您可以使用 `observe()` 方法；对于 Kotlin 数据流，您可以使用 `collect()` 方法或其变体。

在界面中使用可观察数据容器时，请务必考虑界面的生命周期。这非常重要，因为当未向用户显示视图时，界面不应观察界面状态。使用 `LiveData` 时，`LifecycleOwner` 会隐式处理生命周期问题。使用数据流时，最好通过适当的协程作用域和 `repeatOnLifecycle` API 来处理这一任务

### 在屏幕上显示错误

显示错误与显示正在执行的操作类似都能通过用于表明它们是否存在的布尔值来轻松表示。不过，错误可能还包括要传回给用户的关联消息，或包含与其关联的操作（旨在重试失败的操作）。因此，无论正在执行的操作是否正在加载，可能都需要使用托管以下数据的数据类对错误状态进行建模：适合错误上下文的元数据。

以上一部分中的示例为例，它在获取报道时会显示进度条。如果此操作导致错误，您可能希望向用户显示一条或多条消息，详细说明出现了什么错误。

```java
data class Message(val id: Long, val message: String)

data class NewsUiState(
    val userMessages: List<Message> = listOf(),
    ...
)
```

然后，错误消息便能够以界面元素（例如[信息提示控件](https://material.io/components/snackbars/android)）的形式呈现给用户。由于这与界面事件的提供和使用方式有关，因此请参阅[界面事件](https://developer.android.google.cn/jetpack/guide/ui-layer/events?hl=zh-cn)页面了解详情。

## 线程处理和并发

在 ViewModel 中执行的所有工作都应具有主线程安全性（即从主线程调用是安全的）。这是因为数据层和网域层负责将工作移至其他线程。

如果 ViewModel 执行长时间运行的操作，则还要负责将相应逻辑移至后台线程。Kotlin 协程是管理并发操作的绝佳方式，Jetpack 架构组件则为其提供内置支持。如需详细了解如何在 Android 应用中使用协程，请参阅 [Android 上的 Kotlin 协程](https://developer.android.google.cn/kotlin/coroutines?hl=zh-cn)。

## 导航

应用导航的变化通常是由类似于事件的发出操作驱动的。例如，在 `SignInViewModel` 类执行登录后，`UiState` 可能会有一个 `isSignedIn` 字段被设为 `true`。此类触发器的使用方式应与上面[使用界面状态](https://developer.android.google.cn/jetpack/guide/ui-layer?hl=zh-cn#consume-ui-state)部分介绍的方式相同，不过使用实现应遵从[导航组件](https://developer.android.google.cn/guide/navigation?hl=zh-cn)。

## Paging

[Paging 库](https://developer.android.google.cn/topic/libraries/architecture/paging/v3-overview?hl=zh-cn)通过一个称为 `PagingData` 的类型在界面中使用。由于 `PagingData` 表示并包含可以随时间变化的内容（换句话说，它不是不可变类型），因此它不应以不可变界面状态表示。相反，您应在单独的流中独立地从 ViewModel 中公开它。如需具体示例，请参阅 [Android Paging](https://developer.android.google.cn/codelabs/android-paging?hl=zh-cn) Codelab。

## 动画

为了提供流畅的顶级导航过渡，您可能需要等待第二个屏幕加载数据，然后再启动动画。Android 视图框架提供了一些钩子，以便通过 [`postponeEnterTransition()`](https://developer.android.google.cn/reference/androidx/fragment/app/Fragment?hl=zh-cn#postponeEnterTransition()) 和 [`startPostponedEnterTransition()`](https://developer.android.google.cn/reference/androidx/fragment/app/Fragment?hl=zh-cn#startPostponedEnterTransition()) API 延迟 fragment 目的地之间的过渡。这些 API 提供了一种方法来确保做到以下一点：在界面通过动画过渡到第二个屏幕之前，第二个屏幕上的界面元素（通常是从网络获取的图片）已做好显示准备。如需了解更多详情和实现细节，请参阅 [Android Motion 示例](https://github.com/android/animation-samples/tree/main/Motion)。

# 提问：

## 能在VieowModel内持有MainActivity内变量的单例吗

在 ViewModel 内部直接持有 MainActivity 内部的变量实例不是一个推荐的做法。ViewModel 应该是与 UI 无关的，它主要负责管理与 UI 相关的数据和业务逻辑，而不应该直接持有 Activity 或其它 Android 组件的引用。

可能会导致内存泄漏，因为 ViewModel 的生命周期可能比 Activity 更长。当 Activity 被销毁时，ViewModel 仍然持有对 Activity 的引用，这可能会阻止 Activity 被回收，从而导致内存泄漏。

可以通过回调、接口或 LiveData 等方式，将需要的信息传递给 ViewModel，而不是直接持有 Activity 的引用。

另外，如果某个变量是全局的并且在整个应用中都需要访问，你可以考虑创建一个单例类来管理这个变量。这样的单例类可以在整个应用的生命周期内持有这个变量，并且可以在需要时被 ViewModel 或其它组件使用。但要注意单例的设计，确保不会因为单例的生命周期过长而导致内存泄漏问题。

## 用户的访问权限应该在哪里写，界面层还是数据层

用户的访问权限应该在数据层进行控制。在典型的应用架构中，数据层（例如数据访问层、存储库层或服务层）负责管理和处理数据，并提供对数据的访问和操作。因此，权限控制应该位于这个层级，以确保对数据的安全访问。

通过在数据层进行权限控制，可以确保数据的安全性，并确保数据访问的一致性。这样即使界面层发生变化或有多个界面层，都可以保证访问权限的统一和数据的安全性。

## 在创建数据流的时候应该让每个页面有一个数据流还是应该按数据之间的关系来创建数据流呢

在某些情况下，按照页面的方式创建数据流可能更合适，特别是当页面之间的状态变化不相关或者相对独立时。每个页面都有自己的数据流可以简化代码和逻辑，提高可维护性和可测试性。这种方式适用于简单的页面或者页面之间的交互较少的情况。

在其他情况下，按照数据之间的关系创建数据流可能更合适。有时候，不同页面之间的状态是相关联的，例如，在购物车示例中，商品列表、已选商品和总价格之间存在关联。在这种情况下，将相关的状态放在同一个数据流中有助于管理和维护这些状态，并确保它们之间的一致性。

## 数据流指的就是ViewModel是吗

在 Android 应用中，数据流通常指的是数据在应用内部的流动和管理方式，它包括了从数据源到界面的整个数据处理和传递过程。

虽然 ViewModel 是管理界面相关数据的一种方式，但数据流的概念更宽泛，它不仅仅指 ViewModel。数据流可以涉及多个组件、数据源、中间层以及业务逻辑，包括但不限于 ViewModel。

在典型的 Android 架构中，数据流可能涉及以下组件和部分：

1. **数据源**：可能是数据库、网络请求、本地文件等等。数据从这些源头获取并进行处理。
2. **Repository/数据访问层**：负责与不同数据源交互，并提供统一的接口供 ViewModel 或其他组件使用。
3. **ViewModel**：负责管理界面相关的数据，并向界面提供数据。它可能是数据流中的一个重要部分，用来处理数据的业务逻辑并暴露给界面。
4. **界面（Activity、Fragment 等）**：负责展示数据，并与用户进行交互。

## 那么我在ViewModel创建的数据流在其他部分也应该对应吗？还是说其它部分可以创建他们自己的数据流

通常情况下，数据流在整个应用中应该是一致的，不同部分应该对应相同的数据流。这样可以确保应用中的数据流动和处理方式是一致的，避免重复的逻辑和数据不一致的情况。

不同部分（比如不同的 ViewModel、不同的数据访问层、不同的业务逻辑层）在处理相同类型的数据时，最好采用相同的数据流。

当然，在某些特定场景下，不同部分可能需要自己的数据流来处理特定的需求或逻辑。但是应该尽量保持数据流的一致性和统一性，确保数据在整个应用中的流动方式是一致和可预测的。

## 除了ViewModel之外，还有其他的能够用来充当ViewModel的角色的吗

1. **Presenter**：在 MVP（Model-View-Presenter）架构中，Presenter 扮演类似于 ViewModel 的角色，负责处理界面逻辑和状态管理。它连接 View 和 Model，但通常不直接持有数据，而是通过 View 接口与 View 进行交互。
2. **Controller**：在 MVC（Model-View-Controller）架构中，Controller 负责处理用户输入并更新模型和视图。它类似于 Presenter，负责控制界面和数据之间的交互。
3. **Redux/Flux 架构**：这是一种基于单一不可变状态树的前端架构，通过 Store 来管理应用的状态。类似于 ViewModel，Store 存储应用状态并暴露给界面使用，同时使用 Action 和 Reducer 来管理状态变化。
4. **MobX**：一种用于状态管理的库，类似于 Redux，但提供了更灵活的方式来管理状态和响应状态变化。它可以用于管理界面状态，类似于 ViewModel。
5. **RxJava/RxKotlin**：虽然 RxJava/RxKotlin 本身不是 ViewModel，但它们提供了一种响应式编程的方式来处理异步数据流和事件。可以与 ViewModel 结合使用来管理和处理数据流。

## distinctUntilChanged()

`distinctUntilChanged()` 是一种用于过滤流（Observable、Flowable等）中重复数据的操作符。它会仅允许不同于前一个元素的数据通过，并过滤掉连续重复的元素。

### Transformations.distinctUntilChanged()

如果您使用 LiveData，Android 架构组件库中提供了 `Transformations.distinctUntilChanged()` 方法，用于过滤 LiveData 中连续重复的数据。您可以在 ViewModel 中使用这个方法：

```java
public class MyViewModel extends ViewModel {
    private MutableLiveData<String> myLiveData = new MutableLiveData<>();
    private LiveData<String> distinctLiveData = Transformations.distinctUntilChanged(myLiveData);

    public void setValue(String newValue) {
        myLiveData.setValue(newValue);
    }

    public LiveData<String> getDistinctLiveData() {
        return distinctLiveData;
    }
}
```

## 在 ViewModel 中执行的所有工作都应具有主线程安全性（即从主线程调用是安全的）。

主线程安全性意味着 ViewModel 中的操作都应该能够安全地在主线程执行，这样才能与 UI 元素进行交互而不引发线程安全问题。

ViewModel 应当遵循以下原则：

1. **UI 更新**：ViewModel 中的数据变化应当能够被 UI 监听并在主线程上更新。这通常是通过 LiveData 或 Kotlin Flows 的方式实现的，这些机制能够确保数据变化时能够在主线程上分发通知。
2. **避免耗时操作**：ViewModel 中避免执行长时间运行的操作或耗时操作，特别是在主线程上。长时间运行的操作应当移至其他线程执行，例如使用 Kotlin 的协程或 RxJava 等异步框架。
3. **数据处理**：ViewModel 可以处理数据，但是它不应该直接处理与业务逻辑无关的长时间操作或者 I/O 操作，这些应该由数据层或者其他合适的组件来处理。
4. **线程安全性**：如果 ViewModel 中需要进行线程切换或者执行后台操作，要确保在适当的时机和方式下进行，以避免线程安全问题。

## 界面逻辑（尤其是在涉及 Context 等界面类型时）应位于界面中，而非 ViewModel 中。

如果界面变得越来越复杂，并且您希望将界面逻辑委托给另一个类，以便有利于进行测试和关注点分离，您可以创建一个简单的类作为状态容器。在界面中创建的简单类可以采用 Android SDK 依赖项，因为它们遵循界面的生命周期；

## 依赖 Android SDK是什么意思？

依赖 Android SDK 意味着你的代码或类使用了 Android 提供的特定类、接口或功能。Android SDK 是 Android 软件开发工具包（Software Development Kit）的缩写，它包含了开发 Android 应用所需的库、工具和资源。

当你的代码依赖于 Android SDK 时，它可能涉及使用诸如 `Context`、`Activity`、`Fragment`、`Intent` 等 Android 框架提供的类或者相关功能。这些类和功能可以访问设备的硬件、提供界面交互、管理生命周期等。

例如，在 Android 应用开发中，访问设备的权限、处理 UI 事件、与系统服务交互等操作通常都需要依赖 Android SDK 中提供的类和方法。

## 创建一个简单的类作为状态容器的例子

假设你有一个 Activity 或 Fragment，它负责展示一组数据，并且这个数据的处理逻辑变得复杂。你可以创建一个简单的类来处理这些逻辑，这个类可能会依赖于 Android SDK 中的一些类和方法。下面是一个简单的示例：

```java
public class DataProcessor {
    private List<String> data = new ArrayList<>();

    public void addData(String newData) {
        // 在数据处理类中处理新添加的数据
        data.add(newData);
        // 可以执行其他逻辑，如数据校验、转换等
    }

    public void processData() {
        // 在数据处理类中处理数据
        // 可以对 data 进行处理，如筛选、排序等操作
    }

    public List<String> getData() {
        return data;
    }
}

```

```java
public class MyActivity extends AppCompatActivity {
    private DataProcessor dataProcessor = new DataProcessor();

    // 假设这里有一些 UI 相关的操作，如按钮点击事件等

    private void handleNewData(String newData) {
        dataProcessor.addData(newData);
        dataProcessor.processData();
        updateUIWithData();
    }

    private void updateUIWithData() {
        // 从 DataProcessor 中获取处理后的数据并更新 UI
        List<String> processedData = dataProcessor.getData();
        // 更新 UI 控件展示数据
    }
}

```

这个示例中，`DataProcessor` 类充当了状态容器，负责处理和管理数据逻辑，而 Activity 则专注于 UI 相关的操作。通过这种方式，你可以将复杂的数据处理逻辑从 Activity 或 Fragment 中抽离出来，使代码更清晰、易于维护和测试。

## 什么时候暴露可变数据以允许外部组件修改会比暴露一个包裹可变数据的不可变数据并将可变数据的内部改变方法公开好?

当你需要实现特定的交互或者你的应用逻辑需要多个组件对同一数据进行频繁的修改时，暴露可变数据以允许外部组件修改可能更为合适。

例如，考虑一个聊天应用的消息管理器。这个消息管理器负责管理聊天中的消息，并提供给用户发送消息的接口。在这种情况下，可能需要暴露可变的消息列表，以便外部组件能够直接添加、删除或修改消息。

这样设计的优势在于，外部组件可以更自由地对消息进行添加、删除等操作，而不需要额外的调用内部方法来修改数据。

## 业务逻辑应该放在ViewModel中还是数据层中？

通常来说，业务逻辑应该放在 ViewModel 中，而数据的获取和处理应该放在数据层。

- **ViewModel** 主要负责处理界面上的交互和业务逻辑。它充当了连接数据层和界面的桥梁，负责处理用户交互、触发数据变更、调用数据层的方法等。ViewModel 应该包含与界面逻辑直接相关的操作，例如用户输入验证、数据转换、界面状态管理等。
- **数据层** 则专注于数据的获取、存储和处理。这包括与数据库、网络或其他数据源的交互、数据的读取、写入、转换等操作。数据层负责管理数据的来源和提供数据的适配，但不应包含业务逻辑，而应该保持专注于数据的管理和操作。